### 软件开发相关原则

> 更新于2019-02-26/27

[原文链接](https://www.timsommer.be/famous-laws-of-software-development/)

### 导读
和其它领域一样，在软件开发的世界中存在一些有意思的、有原则的著名定律。程序员、开发人员、项目经理和设计师在会议中或者聊天中经常会使用它们。大多交谈时我们更倾向于点头附和，不愿意让我们的伙伴知道实际上我们从来没有听过那些叫布鲁克、摩尔或者沃斯的人。

这些定律由是某些规则、原则、或者是那些鼓舞人心的名言组成。有些时候它们是有趣的、幽默的、值得学习的，并且每条“定律”的背后都有让人称奇的故事。

在这篇文章中，我将分享我收集到的一些著名的，且在开发中使用最多的定律作出解释和关于我的一些思考。

这篇文章很长，如果你想跳过一些，我已经建好了目录：
- 墨菲定律
- 布鲁克定律
- 霍夫斯塔德定律
- 康威定律定律
- 伯斯塔尔定律
- 帕累托原则
- 彼得原则
- 克尔克霍夫原则
- 莱纳斯定律
- 摩尔定律
- 沃思定律
- 九十九条规则
- 克努斯最优原则
- 诺维格定律


### 墨菲定律
可能是最著名的定律之一，很大的一个原因是因为它不仅使用于软件开发领域。该定律指出:
> 如果某件事情可能会出错，那么它一定会

**第一个推论**：如果它能运行，你可能不应该去写它

**第二个推论**：骂娘是所有程序员说的最流利的语言，没有之一

**结论**：计算机只会做你写好的，而不会做你想要的


防御性编程，版本控制，厄运场景（应对那些该死的僵尸服务器攻击），TDD，MDD等等。都是预防该定律的最佳实践。

### 布鲁克定律
大多数开发人员——无论是有意还是无意——都会有布鲁克定律的经验，该定律指出:

> 在一个延期的软件项目中添加人力会使它变的延期变的更长。

如果一个项目延期，简单地增加人力很可能会有灾难性的结果。查看和复查编程效率水平、软件方法、技术架构等，反而会有更好的结果。如果没有，这可能意味着霍夫斯塔德定律也在发挥作用。

### 霍夫斯塔德定律
霍夫斯塔德定律是道格拉斯·霍夫斯塔德写的，并以他的名字命名。

这条定律当然不能与美剧《生活大爆炸》中的莱纳德·霍夫斯塔德相混淆。即使他说的话对你具有意义。(莱纳德：高中毕业都12年了，我还是那个书呆子。)

该定律指出:
> 它总是比你预期的要长，即使你考虑到了霍夫斯塔德定律。

这条“定律”说的是完成相当复杂任务所需要的时间是难以精确估算的。该定律的反映了尽管尽了最大努力，包括了解任务的复杂度，但是要对复杂任务进行估算仍然是非常困难的。

这就是在你做任何估算之前必须有一个缓冲区。如果你想知道如何提供更好的估算，请阅读我发布的另一篇文章：[估算魔法](https://www.timsommer.be/estimation-wizardry)

### 康威定律
> 任何软件都反映了它生产时的组织架构

或者更清晰的说：
> 组织形式等同其设计的系统架构

在许多组织团队中时根据他们的职业技能来划分的。因此你会有前端开发、后端开发和数据库开发人员。简而言之，如果有人想要改变某些人对某些事情的所有权是很困难的。

在一个有限的条件下去组织团队要好很多，而且越来越多是以这种形式实现的。像微服务这样的体系架构围绕服务边界来组织他们的团队，而不是孤立的技术体系结构。

因此，组织团队使其看起来像你的目标架构，这样会更容易实现。这样可以帮你预防康威定律。

### 波斯特定律又称稳健性原则
> 在你输出的东西上要保守，在你接受的东西上要自由

Jon Postel起初将此阐述为使TCP实现更健壮的一个原则。这个原则也体现在HTML中，许多人认为这是它成功和失败的原因，这取决于你问谁。

在当今高度紧张的政治环境中，波斯特定律是一个统一的概念。

### 帕累托原则又称2-8定律

> 在大多现象中，80%的后果是那20%的引起的

这个痛苦原则背后揭示的是代码中80%的bug是由20%的代码引起的。

换句话说，公司80%的工作是由20%的员工完成的。问题是你并不总是清楚那20%。

### 彼得原则

有时，这是一个令人相当沮丧的定律，如果你正好亲身经历过。

> 在等级制度中，每个员工都倾向于提升到他无法胜任的等级

只要读读Dilbert(或看看办公室》)就可以得到一些这方面的例子。至于Dilbert，这个远远不是我最喜欢的！

### 克尔克霍夫原理
在密码学中，这个系统应该是安全的，除了一小部分信息——密钥，这是被大家公认的。

这是公钥密码学的主要原理。

### 莱纳斯定律
这个定律是以Linux之父莱纳斯.托瓦尔兹的名字命名的，该定律指出：
> 只要有足够多的眼睛，就可以让所有bug浮现

这条定律引用了著名的“[教堂和集市](https://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar)”文章来阐述，对两种不同的软件开发模式对比做出了解释：
- 教堂模式中，其中源代码在每个软件版本中都可用，但是在两个版本之间开发的代码仅限于软件开发人员使用。
- 集市模式中，代码在互联网上是公开的

结论是，源代码越广泛地用于公共测试、实验、安全各种形式的代码bug也被发现的越快

### 摩尔定律
> 每单位成本下的计算机，每24个月其性能将会翻一倍

最流行的版本是:

> 集成电路上的晶体管数量将在大约18个月内翻一番。

或者
> 计算机的处理速度将每两年翻一番！

### 沃斯定律
> 软件更新速度比硬件快！

延续摩尔定律！

### 90-90法则
> 前90%的代码要花费10%的时间，剩下的10%代码需要另外90%的时间

如此真实。还会有人不同意吗？

### 克努特优化原理
> 过早优化是所有问题的根源。

首先编写代码，然后意识到瓶颈并修复它！

### 诺维格定律
> 任何技术其渗透率超过50%，都不会再翻倍（在任何月内）

### 总结

我喜欢这些“定律”，他们都有自己的故事和背景。作为顾问和架构师你必须熟悉他们。所以对我来说或对你而言，我有一张清单，上面有我了解在软件开发中使用最多且最著名的定律。

我能知道你最喜欢的定律吗？你赞同或不赞同某条定律，或在其中任何一条有过有趣的经历，你最喜欢什么？快在底部下方留言让我知道！