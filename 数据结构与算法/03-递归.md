# 递归

> 更新时间：2019-02-28

在我还没看这篇文章的时候，对递归的理解一直都是用“脑子”来循环一层层的遍历，这样给自己造成了障碍，正确的方法是：
> 把问题A分解为若干个子问题B、C、D，但其实你只要考虑A和B两层之间的关系即可
> 因为其它的都是一样的，关键是推导出递归公式！！！


### 例子
假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？

如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2

##### 递归公式
```
// 列举递条件
f(1) = 1;
f(2) = 2;
// 递归公式
f(n) = f(n-1)+f(n-2)
```

##### 代码
```
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```


### 递归的三个条件
- 该问题可以拆解为子问题来处理
- 该问题拆解成子问题后，除了数据规模，其它求解思路一样
- 存在递归结束条件

### 注意事项
- 堆栈溢出

    >    如果栈很深那么会出现堆栈溢出
- 重复计算

    >    比如上面的代码，如果n=6，那么f(4)就会重复2次，如果更下面的数，重复的次数还更多


### 更改递归代码
递归有利有弊，实际情况中综合考量

f(x)=f(x-1)+1 改为非递归
```
int f(int n) {
    int ret = 1;
    for(int i=2; i<=n; i++) {
        ret = ret + 1;
    }
    return ret;
}
```

f(n) = f(n-1) + f(n-1)
```
// 迭代法
public static int func(int num) {
        if(num == 1) {
            return 1;
        }
        if(num == 2) {
            return 2;
        }

        int ret = 0;
        int pre = 2;
        int prepre = 1;
        for (int i=3; i<=num; i++) {
            System.out.println("ret:"+ret+"  pre:"+pre+"   prepre:"+prepre);
            ret = pre + prepre;
            prepre = pre;
            pre = ret;
        }
        return ret;
    }
```



### 递归应用
DFS 深度优先搜索

前中后序二叉树遍历