# 散列表

>更新时间：2019-04-06

是基于数组和链表实现的

### Hash函数

Hash函数的好坏，直接影响到散列表的性能，尤其重要，减少冲突概率

### Hash冲突
Hash冲突是散列表存在的最大问题，即使是那些牛逼的MD5，SHA都没办法避免，有两类方法可以解决，分别是开放寻址法和链表法。

##### 开放寻址法
核心思想是如果key冲突，我们就从该key开始往下开始找位置，直到找到一个空位置就插进去，然后取的时候，通过key进行查找，查到了以后进行匹配，如果不相等，继续往下找，直到匹配或者找到一个空位置才结束

根据存入和查找的特性，这种方法删除不能把元素置为空，而是用一个标记来表示该元素已删除

缺点是随着插入的数据越多，空闲位置越少，冲突越多，极端情况下，复杂度为O(n),所以引入**装载因子**这个参数，来进行扩容，装载因子越大，空闲位置越少，冲突就越大,计算方法如下：
```
装载因子 = 表中已有的元素个数 / 散列表的长度
```

这种方法适合数据量小的情况，比如Java的ThreadLocalMap就是用开放寻址法
##### 链表法
这种方法简单所以更加的常用。核心思想是将key放大bucket中，每个bucket下都有一个链表，如果有重复的key，就依次放到对应的bucket中的链表上，这样插入的复杂度就是O(1),查找和删除是O(n)

### 工业级别的散列实现
分析HashMap的底层原理，来看看是如何实现的高性能

##### 1. 初始大小
HashMap默认的初始值是16，这个值是可以修改的，但其目的是为了减少动态扩容的次数

##### 2. 装载因子和动态扩容
最大的装载因子默认是0.75，当元素个数超过 0.75 x capacity时，就会进行动态扩容，变成原来的2倍。扩容是极其消耗性能的操作，要把原来的搬到一个新的HashMap中，应该尽量减少扩容操作

##### 3. 散列冲突
HashMap采用链表法来解决Hash冲突，但是数据太大，避免不了链表变长，严重影响HashMap性能。

JDK1.8中引入了红黑树，当链表的长度超过8，就转换为红黑树，当小于6时，又将红黑树还原成链表

### Hash常见应用
1. 安全加密
2. 唯一标识
3. 数据校验
4. 散列函数
5. 负载均衡
6. 数据分片
7. 分布式存储，一致性Hash


# 散列表
是基于数组实现的

### Hash函数
Hash函数的好坏，直接影响到散列表的性能，尤其重要，减少冲突概率

### Hash冲突
Hash冲突是散列表存在的最大问题，即使是那些牛逼的MD5，SHA都没办法避免，有两类方法可以解决，分别是开放寻址法和链表法。

##### 开放寻址法
核心思想是如果key冲突，我们就从该key开始往下开始找位置，直到找到一个空位置就插进去，然后取的时候，通过key进行查找，查到了以后进行匹配，如果不相等，继续往下找，直到匹配或者找到一个空位置才结束

根据存入和查找的特性，这种方法删除不能把元素置为空，而是用一个标记来表示该元素已删除

缺点是随着插入的数据越多，空闲位置越少，冲突越多，极端情况下，复杂度为O(n),所以引入**装载因子**这个参数，来进行扩容，装载因子越大，空闲位置越少，冲突就越大,计算方法如下：
```
装载因子 = 表中已有的元素个数 / 散列表的长度
```

这种方法适合数据量小的情况，比如Java的ThreadLocalMap就是用开放寻址法
##### 链表法
这种方法简单所以更加的常用。核心思想是将key放大bucket中，每个bucket下都有一个链表，如果有重复的key，就依次放到对应的bucket中的链表上，这样插入的复杂度就是O(1),查找和删除是O(n)

### 工业级别的散列实现
分析HashMap的底层原理，来看看是如何实现的高性能

##### 1. 初始大小
HashMap默认的初始值是16，这个值是可以修改的，但其目的是为了减少动态扩容的次数

##### 2. 装载因子和动态扩容
最大的装载因子默认是0.75，当元素个数超过 0.75 x capacity时，就会进行动态扩容，变成原来的2倍。扩容是极其消耗性能的操作，要把原来的搬到一个新的HashMap中，应该尽量减少扩容操作

##### 3. 散列冲突
HashMap采用链表法来解决Hash冲突，但是数据太大，避免不了链表变长，严重影响HashMap性能。

JDK1.8中引入了红黑树，当链表的长度超过8，就转换为红黑树，当小于6时，又将红黑树还原成链表

### Hash常见应用
1. 安全加密
2. 唯一标识
3. 数据校验
4. 散列函数
5. 负载均衡
6. 数据分片
7. 分布式存储，一致性Hash