# 链表

> 更新时间：2019-02-20

链表（Linked list），数组是连续的内存，而它是零散的内存空间

### 链表的特性

链表分配内存只需零散的内存空间即可

链表删除、插入和更新的时间复杂度O(1)

链表随机访问需要遍历整条链表，因此随机访问时间复杂度O(n)

单链表中每个结点除了存储数据以外还记录下一个结点的地址

单链表中有了头结点就可以遍历整条链表

单链表中后继指针为null，说明该结点是尾结点

循环链表的尾结点后继指针指向头结点的地址

双链表比较复杂，因为它引入了前驱指针用来指向上一个结点的后继指针

双链表找到前驱指针的时间复杂度是O(1)

### 单链表

由很多个节点连接而成，上一个节点的指针指向下一个节点，第一个节点我们称为首节点，最后一个节点我们称为尾节点，尾节点的指针指向一个空地址NULL，也因此我们可以判断它是一条单链表中的尾节点
![image](https://raw.githubusercontent.com/liueleven/study/master/%E5%9B%BE%E5%BA%93/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/13-%E5%8D%95%E9%93%BE%E8%A1%A8.png)
单链表的插入和删除时间复杂度是O(1),只需要移动下指针的指向就可以了，但是查询的复杂度就比较高了是O(n)


### 循环链表
和单链表不同的，将尾节点的指针指向了首节点


### 双向链表
单链表我们知道都是单项的，双向链表顾名思义就是双向的。每个节点的后继指针指向下一个节点的前驱指针，同时前驱指针也指向后继指针。

双向链表虽然占内存，但是某些情况下，快！


### 链表的使用
- LRU缓存淘汰算法

常见的缓存策略有：先进先出策略（FIFO：First In First Out）、最少使用策略（LFU：Least Frequently Used）、最近最少使用策略（LRU：Least Recently Used），可以使用单链表实现LRU算法，实现思路：
>
>维护一个有序链表，最常用的数据放到链表头，如果要访问新的数据，我们从头部开始遍历，如果找到就把原来的位置删除，移动到头部，如果没有找到该数据，先判断链表是否满了，如果满了，删除尾部节点，将该数据插入到头部，如果没满，直接插到头部